[{"authors":null,"categories":null,"content":"We\u0026rsquo;ve been working for some time doing Continuous Delivery in our teams, and we found that managing feature toggles in our code was a challenge. Not only because toggles are complex to implement properly and each of us implemented their toggles in different ways, but also because toggles evolved rapidly when we were releasing new features.\nA good example of the evolution of a toggle would be to, first, enable our new shiny feature for a subset of users. When the feature has been probed with a subset of the customers, we can enable it for a bigger set of customers (probably multiple countries). However, we want to make sure that the new feature doesn\u0026rsquo;t break the system that is already in production, so we would want to disable it in case the new service that we depend on is down. After testing the new feature under a big load, we might want to progressively enable it to all customers, but with the ability to disable it quickly to all of our customers if we find something problematic (like a security bug). At the end, we want to just enable the feature for all customers and clean up the feature toggle.\nHowever, managing this flow manually is really complex, is error prone and messes up with the code. For example, we would have with something like:\nvar myRelease = feaggle.release(\u0026quot;MY_RELEASE\u0026quot;); var myExperiment = feaggle.experiment(\u0026quot;MY_RELEASE\u0026quot;); if (myRelease.isEnabled() \u0026amp;\u0026amp; myExperiment.isEnabledFor(myCurrentUser)) { newShinyFeature(); }  That later would evolve to:\nvar myRelease = feaggle.release(\u0026quot;MY_RELEASE\u0026quot;); var myExperiment = feaggle.experiment(\u0026quot;MY_EXPERIMENT\u0026quot;); var reportsService = feaggle.operational(\u0026quot;REPORTS_SERVICE_IS_UP\u0026quot;); if (myRelease.isEnabled() \u0026amp;\u0026amp; myExperiment.isEnabledFor(myCurrentUser) \u0026amp;\u0026amp; reportsService.isEnabled()) { newShinyFeature(); }  We found that every change to our rollout strategy would mean that we changed the code that was in production, meaning that we could break it (spoiler, we broke it).\nWe though that having some kind of abstraction over a feature, that could evolve during the lifetime of the feature, was necessary. That\u0026rsquo;s why we came up with the concept of drum-roll Epic.\nSo, what is an epic itself? An epic aggregates a set of toggles (of different types) and is enabled only if all toggles inside the epic are enabled for a cohort. Building an epic is quite easy:\nEpic\u0026lt;MyCohort\u0026gt; epic = feaggle.epic() .release(feaggle.release(\u0026quot;MY_RELEASE\u0026quot;)) // you can add more than one release toggle, just calling .release again .experiment(feaggle.experiment(\u0026quot;MY_EXPERIMENT\u0026quot;)) // also, you can add more than one experiment with .experiment .operational(feaggle.operational(\u0026quot;REPORTS_SERVICE_IS_UP\u0026quot;)) // also here :D .build(); // usage: if (epic.isEnabledFor(myCurrentUser)) { newShinyFeature(); }  There are several awesome features from epics that will let you fall in love with them:\n Epics are lazy. They will evaluate toggles by complexity until finds one that is disabled. For example, if a release is turned off, the epic won\u0026rsquo;t call any experiment or operational toggle. Epics are configured once and can be injected, if you want to change how they work, just reconfigure them. Epics are unaware of how other toggles work. You can use epics with toggles that are stored in your database with feaggle-jdbc or toggles in memory. Your epic won\u0026rsquo;t change.  We believe that epics will be a game changer on how we do Continuous Deliver, as we have more power on how we release our features without sacrificing ease. You can start using epics in feaggle 2.0.0: despite the major version, it\u0026rsquo;s backwards compatible to feaggle 1.x and feaggle-jdbc!\nRead more information on how to use feaggle in the the feaggle repository and remember that if you have any feedback or suggestion,please fill us an issue so we can keep track of them üòç.\n","date":1551830400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551830400,"objectID":"5956b2424addef70476ce8f2f1c6267e","permalink":"http://feaggle.github.io/blog/welcome-epics/","publishdate":"2019-03-06T00:00:00Z","relpermalink":"/blog/welcome-epics/","section":"blog","summary":"We\u0026rsquo;ve been working for some time doing Continuous Delivery in our teams, and we found that managing feature toggles in our code was a challenge. Not only because toggles are complex to implement properly and each of us implemented their toggles in different ways, but also because toggles evolved rapidly when we were releasing new features.\nA good example of the evolution of a toggle would be to, first, enable our new shiny feature for a subset of users.","tags":null,"title":"Welcome, Epics!","type":"blog"},{"authors":null,"categories":null,"content":"","date":1543536000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543536000,"objectID":"f85aa3ecad9018a932f3d3bc0b0c139b","permalink":"http://feaggle.github.io/tutorial/getting-started/","publishdate":"2018-11-30T00:00:00Z","relpermalink":"/tutorial/getting-started/","section":"tutorial","summary":"","tags":null,"title":"Getting Started","type":"tutorial"}]